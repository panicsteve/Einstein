// ==============================// Fichier:			ROMDumper.cp// Projet:			ROM Dumper// Ecrit par:		Paul Guyot (pguyot@kallisys.net)// // Créé le:			13/1/2005// Tabulation:		4 espaces// // Copyright:		© 2005 by Paul Guyot.// 					Tous droits réservés pour tous pays.// ===========// $Id$// ===========// NewtonOS#include <NSandDDKIncludes.h>#include <Unicode.h>#include <NewtonScript.h>#include <OSErrors.h>#include <UStringUtils.h>// ------------------------------------------------------------------------	////	* RefToULong( Ref inRef )// ------------------------------------------------------------------------	//// Cette transforme un objet NewtonScript en un entier.// Si c'est un entier, retourne la valeur.// Si c'est une chaîne, elle est traduite.unsigned long RefToULong( Ref inRef ){	unsigned long theResult;		while(1)	{			// If it is an Int, just cast it		if (ISINT(inRef))		{			theResult = RINT(inRef);			break;		}		if (::IsString(inRef))		{			UniChar* theUCString = ::GetCString(inRef);	// La chaine de caractères.			char theCString[32];	// Espérons que c'est assez.			::ConvertFromUnicode( (const Character*) theUCString, theCString );			while (1) // False loop^			{				if (::sscanf( theCString, "#%i", &theResult ) == 1)				{					break;				}				if (::sscanf( theCString, "0d%i", &theResult ) == 1)				{					break;				}				if (::sscanf( theCString, "0x%X", &theResult ) == 1)				{					break;				}				if (::sscanf( theCString, "$%X", &theResult ) == 1)				{					break;				}				if (::sscanf( theCString, "%X", &theResult ) == 1)				{					break;				}//				::ThrowMsg("Bad format for parameter. Format is #1234, 0d1234, 0x1234, $1234, 1234 (default is hexa).");				break;			}			break;		}//		::ThrowMsg("Bad parameter's type try int or string"); 		ThrowBadTypeWithFrameData(kNSErrNotAnInteger, theResult);		break;	}		return theResult;}// -------------------------------------------------------------------------- ////  * Dump( RefArg, RefArg, RefArg )// -------------------------------------------------------------------------- //extern "C" RefDump( RefArg inRcvr, RefArg inBaseAddress, RefArg outBinary ){	ULong theAddress = RefToULong( inBaseAddress );		// Check the binary is a binary.	if (!::IsBinary(outBinary))	{		ThrowBadTypeWithFrameData(kNSErrNotABinaryObject, outBinary);	}	// Get the size of the binary.	ULong theSize = Length(outBinary);		WITH_LOCKED_BINARY(outBinary, outBinaryPtr)		ULong* theBinaryCrsr = (ULong*) outBinaryPtr;		ULong* theROMCrsr = (ULong*) theAddress;		ULong* theEnd = (ULong*) (theAddress + theSize);		while (theROMCrsr < theEnd)		{			*theBinaryCrsr++ = *theROMCrsr++;		}	END_WITH_LOCKED_BINARY(outBinary)		return NILREF;}// ====================================================== //// "Yacc" owes much to a most stimulating collection oEOF //// ====================================================== //