// ShareTransport for iOS// Copyright (C) 2015  J. Bordens// Derrived from Paul Guyot's NSRuntime in Einstein// This program is free software; you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation; either version 2 of the License, or// (at your option) any later version.// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// You should have received a copy of the GNU General Public License along// with this program; if not, write to the Free Software Foundation, Inc.,// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.#include <stdio.h>#include <NewtonScript.h>#include "NSandDDKIncludes.h"// Defined in NativeiOSCalls.a, which defines a stub thet triggers a// coprocessor instruction.  Code in the Einstein emulator then reads// the various registers and memory to obtain the parameters.extern long int HostGetCPUArchitecture();extern NewtonErr HostMakeNSInvocation(void* returnObj, const UniChar* className, const UniChar* selectorString);extern NewtonErr HostSetInvocationTarget(void* invocationObj, void* targetObj);extern NewtonErr HostSetInvocationArgument_Object(void* invocationObj, void* argumentObj, unsigned long index);extern NewtonErr HostInvoke(void* invocationObj);extern NewtonErr HostGetInvocationReturn_Object(void* invocationObj, void* returnObj);extern NewtonErr HostReleaseObject(void* objectToRelease);extern NewtonErr HostMakeNSString(void* returnObj, const UniChar* string);// For simple debuggingvoid print(char* string) {	NSCallGlobalFn(SYM(print), MakeString(string));}extern "C" Ref MakeNSInvocation(RefArg rcvr, RefArg className, RefArg selectorString) {	// Create a place to stash a 64-bit (or 32 bit) pointer	int pointerBytes = HostGetCPUArchitecture();	Ref pointer = AllocateBinary(SYM(binary), pointerBytes);	// Get a cString from the NewtonScript string	UniChar* classNameCString = GetCString(className);	UniChar* selectorCString = GetCString(selectorString);		NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(pointer, resPtr) {		err = HostMakeNSInvocation(resPtr, classNameCString, selectorCString);	} END_WITH_LOCKED_BINARY(pointer);		if (err) return NILREF;	return pointer;}extern "C" Ref SetInvocationTarget(RefArg rcvr, RefArg invocation, RefArg target) {	NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(invocation, invocationPtr) {		WITH_LOCKED_BINARY(target, targetPtr) {			err = HostSetInvocationTarget(invocationPtr, targetPtr);		} END_WITH_LOCKED_BINARY(target);	} END_WITH_LOCKED_BINARY(invocation);	return MAKEINT(err);}extern "C" Ref SetInvocationArgument_Object(RefArg rcvr, RefArg invocation, RefArg argument, RefArg index) {	NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(invocation, invocationPtr) {		WITH_LOCKED_BINARY(argument, argumentPtr) {			err = HostSetInvocationArgument_Object(invocationPtr, argumentPtr, RINT(index));		} END_WITH_LOCKED_BINARY(argument);	} END_WITH_LOCKED_BINARY(invocation);	return MAKEINT(err);}extern "C" Ref Invoke(RefArg rcvr, RefArg invocation) {	NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(invocation, invocationPtr) {			err = HostInvoke(invocationPtr);	} END_WITH_LOCKED_BINARY(invocation);	return MAKEINT(err);}extern "C" Ref GetInvocationReturn_Object(RefArg rcvr, RefArg invocation) {	// Create a place to stash a 64-bit (or 32 bit) pointer	int pointerBytes = HostGetCPUArchitecture();	Ref pointer = AllocateBinary(SYM(binary), pointerBytes);	NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(invocation, invocationPtr) {		WITH_LOCKED_BINARY(pointer, pointerPtr) {			err = HostGetInvocationReturn_Object(pointerPtr, invocationPtr);		} END_WITH_LOCKED_BINARY(pointer);	} END_WITH_LOCKED_BINARY(invocation);	if (err) return NILREF;	return pointer;		}extern "C" Ref ReleaseObject(RefArg rcvr, RefArg objectToRelease) {	NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(objectToRelease, objectPtr) {			err = HostReleaseObject(objectPtr);	} END_WITH_LOCKED_BINARY(objectToRelease);	return MAKEINT(err);}extern "C" Ref MakeNSString(RefArg rcvr, RefArg string) {	// Create a place to stash a 64-bit pointer	int pointerBytes = HostGetCPUArchitecture();	printf("pointerBytes: %d", pointerBytes);	Ref pointer = AllocateBinary(SYM(binary), pointerBytes);	printf("pointer made");	// Get a cString from the NewtonScript string	UniChar* cString = GetCString(string);		NewtonErr err = 0xFF;	WITH_LOCKED_BINARY(pointer, resPtr) {		err = HostMakeNSString(resPtr, cString);	} END_WITH_LOCKED_BINARY(pointer);		if (err) return NILREF;	return pointer;}